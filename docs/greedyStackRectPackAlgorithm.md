# The Greedy Stack Algorithm
The Greedy Stack Algorithm is a custom algorithm created to automate the packing of 2D textures into a texture atlas in an efficient way that can be done during **setup** which is the code that executes after compilation but before the first call to wake. 

## How the algorithm works
Essentialy the greedy stack algorithm's job is to pack all of the textures into a cube like atlas called a texture atlas, which is an efficient way to store texture data in static meshes. The greedy stack algorithm achieves this by stacking textures on top of each other storing metadata on the pixel position of the top left pixel and the pixel width and height of the image, allowing for easy reading of the data. The algorithm works by heuristically checking left to right on the atlas finding places where the image in question can stack with the least **fragmentation** which is the white space in between images that cannot be filled in because it is too small. Fragmentation is wasted space and should be avoided. Since the greedy stack algorithm is well... greedy, it will always pick the immediate best choice without considering future image sizes.

## How the algorithm checks for the best position
The algorithm stores a heightmap of a single position in the atlas for every height change there is. And by a heightmap I mean an array of ints where every odd index tells the code the lowest point on a specific collumn and every even index tells the code how many collumns remain at that height. This effectively stores rectangular width and height from the point of origin (The top left) that avoids fragmentation. This means the code can take this into account when preventing collisions of image data. Using this heightmap data the code will pick the heighest point it can (The closest point to [x, 0]) where the width is more than or equal to the textures width + 2 (NOTE: we add the plus two to account for padding). If there is no ideal position it is assumed there is no "best solution" so the code will just pick a solution. The code will then pick the lowest possible point on the heightmap or more specifically the WIDEST lowest point. The reason we choose the widest lowest point makes sense as we still want to prevent fragmentation of the texture atlas. Following this algorithm with it's optimizations the code will be able to produce a functional texture atlas with the necessary metadata in a reasonable amount of time.

final note: I don't know for sure, but this algorithm might be just a reimagination of the skyline algorithm which is an algorithm that essentialy stack the textures in a greedy way like what was describe above. Though it might be a bit more optimized this algorithm is likely simpler and can achieve similar "good enough" results.